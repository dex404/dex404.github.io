<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的ub4.0被偷了]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%88%91%E7%9A%84ub4-0%E8%A2%AB%E5%81%B7%E4%BA%86%2F</url>
    <content type="text"><![CDATA[今天是个值得纪念的日子，于2019年8月13日北京时间10点到12点，我的ub被偷了 for(int i=0; ;i++){ cout&lt;&lt;”CNMD，为什么要偷鞋？”;}]]></content>
      <categories>
        <category>不是日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day2]]></title>
    <url>%2F2019%2F08%2F12%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day2%2F</url>
    <content type="text"><![CDATA[上周追了一周剧，是时候继续学习了，今天是第四章-复合类型，over 复合类型数组array数组是一种数据格式，存储多个同类型的值，在内存中依次存储数组的各个元素。 数组的有效下标值十分重要，因为编译器不会检查使用的下表是否有效。 数组的初始化规则：只有在定义数组时才能进行初始化，此后就不行，也不能将一个数组赋值给另一个数组；可以只初始化数组的一部分元素；初始化可以不写【下标值】。C++11的新方法，初始化是可省略等号；大括号内的初始化列标可为空；初始化禁止缩窄转换，例如浮点数转换为整型是缩窄转换。 字符串字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种，C-风格字符串和基于string类库。C-风格字符串，以空字符(\0)结尾，char C[100]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;}; //a string如果最后没有空字符，那么这个数组就不是字符串，有很多函数在处理字符串时，就是遇到空字符为止。 另一种将字符数组初始化为字符串的方法，即字符常量。char simple=&quot;simple&quot;; 空字符在这里被隐藏了。 字符常量和字符串常量我经常搞混字符常量’S’,使用单引号,’S’是83的另一种写法，可用来赋值，char size=’S’,83赋给size字符串常量”S”，使用双引号，表示的是两个字符（S和\0）组成的字符串，”S”是字符串的地址。 任何两个由空白(空格，制表符和换行符)分割的字符串常量都将自动拼接成一个。这两个输出等效 12cout&lt;&lt;&quot;this is dex404&quot; &quot;bloging in my little room.\n&quot;;cout&lt;&lt;&quot;this is dex404 bloging in my little room.\n&quot;; 拼接时不会在被连接的字符串之间添加空格，第一个字符串后面的\0将被第二个字符串的第一个字符取代 将字符串存储到数组中，常用两种方法 12345char life[32]=&quot;life is fantastic,without work&quot;;char life2[32];cout&gt;&gt;&quot;how&apos;s life?&quot;;cin&gt;&gt;life2;cout&lt;&lt;strlen(life)&lt;&lt;sizeof(life2)&lt;&lt;&quot;\n&quot;; strlen(life)计算life数组的字符串长度，即字符数量，不计算空字符。sizeof(life)返回整个数组的长度，而不是数组内元素数量，元素数量=sizeof(life)/sizeof(char); 面向行的输入：istream中的类（如cin)提供的面向行的类成员函数getline()和get()，取一行输入，直到达到换行符。区别是getline()丢弃换行符，get()将换行符保留在输入序列中。 cin.getline(book,10);,这行包含的字符不超过19个。 get()函数有几种变体， 123cin.get(name,ArSize); //和getline()功能相似cin.get(); //读取下一个字符，常用来处理换行符，因为get()调用后，换行符会被保留在输入行中，因此若直接调用第二个get(name2,ArSize),第一个字符就是换行符，直接结束。cin.get(name,ArSize).get(); //将上边两个类成员函数合并，实现上边两条语句的功能。 get()函数的这种特性，叫做函数重载 失效位，当get()读取空行后，将设置失效位（failbit),这将是接下来的输入被阻断，使用cin.clear()函数来回复输入。在输入字符串比分配的空间大时，getline和get都会将余下的字符留到输入队列中，getline()设置失效为。 string类include&lt;string&gt; 可以使用string类型的变量而不是字符数组来存储字符串，很多方面，使用string对象的方式与字符数组相同。1、可以使用c-风格字符串来初始化string对象，即string jame=&quot;jame6&quot;;2、cin&gt;&gt;jame;3、cout&lt;&lt;jame;4、jame[2]; string对象和字符数组之间的区别主要是string对象可以声明为简单变量string jame;,不初始化，但是字符数组的初始化只能在声明时完成，之后就不能在初始化。 123456string jame=&quot;jame6&quot;;string shox;shox=jame; //shox=&quot;jame6&quot;;string cold;cold=jame+shox; //cold=&quot;jame6jame6&quot;jame+=cold; //jame=&quot;jame6✖3&quot; 转义序列&quot;表示双引号cout&lt;&lt;&quot;j6me= \&quot;king of old 6\&quot;\n&quot;; string类使得对字符串的操作更简单，在新增string类之前，使用函数来完成诸如赋值一类的操作#include&lt;cstring&gt; 1234567char allu1[20];char allu2[20]=&quot;botallu&quot;;string kennyS=&quot;king of awper&quot;;strcpy(allu1,allu2); //将字符串复制到字符数组中strcat(allu1,allu2); //将字符串附加到字符数组的末尾int ratingofallu=strlen(allu1); //strlen()获取allu1字符串的长度，接受一个C-风格字符串做参数int ratingofkennyS=kennyS.size(); //.size()获取string对象的长度,size()是string的方法 像前边提过的，字符数组的有效下标值十分重要，因为数组太小，会产生无法存储指定信息的危险，但是string类具有自动调整大小的功能，避免这种问题。 string类的I/O，string对象也可以使用cin&gt;&gt;和cout&lt;&lt;,但是在读取一行而不是一个单词的时候，string对象的处理方法不同， 12cin.getline(zeus,50); //C-风格字符串getline(cin,str); //str是string对象 to be continued]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day1]]></title>
    <url>%2F2019%2F08%2F06%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day1%2F</url>
    <content type="text"><![CDATA[今天是写博客的第一天，记录一下C++学习过程，用的教材是C++ Primer Plus,今天是从本书第3章-处理数据开始记录，这里很多知识都不会写下来，只记些我常忘的或者重要的，over 处理数据1、变量名命名 C++提倡使用有含义的变量名，例如cost_of_trip,这种命名做法通常是用下划线字符将单词隔开，或者从第二个单词开始每个单词的首字母大写，如costOfTrip，命名风格在第二张有讨论，我觉得这个取决个人习惯吧。 C++变量名命名规则如下： 1&gt;名称中只能使用字母字符、数字和下划线—— 2&gt;名称的第一个字符不能是数字 3&gt;区分大小写 4&gt;不能将C++关键字用作名称 5&gt;以两个下划线或下划线和大写字母开头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符 6&gt;C++对于名称的长度没有限制，但是有些平台有长度限制 2、整型 short、int、long、long long,C++规定了最小长度，short至少16位（bit),int至少与short一样长，long至少32位，且至少与int一样长，long long至少64位，且至少与long一样长。 计算机内存的基本单元是位(bit),8位单元可以表示0-255或者-128-127，每增加一位，组合数便加倍，字节通常指的是8位的内存单元，即1 byte=8 bit; sizeof()运算符指出，在使用8位字节系统中，int的长度位4个字节，short是2个字节。 整型的无符号类型，优点是增大变量能够存储的最大值，在整型超越限制值最大最小值时，整型的表现就像钟表，其值将为范围另一端的值。 3、char char最常被用来处理字符，但也可以将用作比short更小的整型。 字符常量的书写方式，最常用的是将字符用单引号括起来，’A’,这种表示法代表的是字符的数值编码，在ASCII系统中，’A’为65，即字符A的ASC码。 C++将一些字符赋予了含义–转义序列， 123cout&lt;&lt;endl; //using the endl manipulator;cout&lt;&lt;&apos;\n&apos;; //using a character constant;cout&lt;&lt;&quot;\n&quot;; //using a string; 都能实现将光标移到下一行。 const限定符 使用const来定义符号常量，如const int Wifes=3000; 便可以在程序中使用Wifes，在定义符号常量时，通常会将首字母大写，有助于区分变量和常量。 如果在声明变量时没有赋值，则该常量值不确定，且在程序中不能修改。 浮点数 计算机将带有小数部分的数字分成两部分存储，一部分表示值，另一部分用于对值进行放大或缩小，例如123.4567和12.34567，可以表示成0.1234567(基准值)和1000（缩放因子），0.1234567和100，缩放因子的作用就是移动小数点的位置，术语浮点因此得名，C++是基于二进制数。 float至少32位，double至少48位，且不少于float,long double至少和double一样多。 在用cout输出浮点数时，cout通常会删除结尾的零，所以可以调用cout.setf(ios_base::fixed, ios_base::floatfield); ios_bash::fixed是设置cout为定点输出格式，ios_bash::floatdield是设置输出时按浮点格式，小数点后有6位数字。因为float只能保证6位有效位。 ###算术运算符 除法运算符（/）的行为取决于操作数的类型。如果两个操作数都是证书，则C++执行整数除法，即小数点被丢弃，结果为整数。如果其中有一个操作数是浮点值，则小数部分被保留，结果为浮点数。 强制类型转换 12int bots=20long (bots) 强制类型转换不会修改变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值 static_cast&lt;long&gt; (bots) 也是一种强制类型转换运算符，还有集中将在15章介绍。 auto 使用关键字auto，让编译器能够根据初始值的类型推断变量的类型。 auto n=100; n is int 在处理复杂类型，如标准模板库STL中的类型时，auto的优势才能显现出来。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
