<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[两数之和&两数相加]]></title>
    <url>%2F2019%2F09%2F18%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 solution: 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int i,j; for(i=0;i&lt;nums.size()-1;i++) &#123; for(j=i+1;j&lt;nums.size();j++) &#123; if(nums[i]+nums[j]==target) return &#123;i,j&#125;; &#125; &#125; return &#123;i,j&#125;; &#125;&#125;; 两数相加给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 solution: 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* root=new ListNode(0); ListNode* ptr=root; int cursor=0; int sum=0; while(cursor||l1||l2) &#123; int val1=(l1 !=nullptr ? l1-&gt;val : 0); int val2= (l2 !=nullptr ? l2-&gt;val :0); sum=val1+val2+cursor; cursor=sum/10; ListNode* sumNode=new ListNode(sum%10); ptr-&gt;next=sumNode; ptr=ptr-&gt;next; if(l1 != nullptr) l1=l1-&gt;next; if(l2 != nullptr) l2=l2-&gt;next; &#125; return root-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新玩具switch]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%96%B0%E7%8E%A9%E5%85%B7switch%2F</url>
    <content type="text"><![CDATA[昨天买了个switch，之前就想买，最近快生日了就买了一个，switch真好玩为了玩switch又买个显示器，打csgo就一直说要买，现在终于买了，虽然不是144的，屏幕毕竟大了，舒服]]></content>
      <categories>
        <category>不是日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day8]]></title>
    <url>%2F2019%2F09%2F18%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day8%2F</url>
    <content type="text"><![CDATA[for循环 表达式和语句 递增运算符和递减运算符：++和– 组合赋值运算符 复合语句 逗号运算符 关系运算符：&gt;,&gt;=,==,&lt;=,&lt;和！= while循环 typedef工具 do while循环 字符输入方法get() 文件尾条件 嵌套循环和二维数组 这章感觉内容比较少，over 循环和关系表达式for循环for不写了 递增运算符和递减运算符递增和递减运算符都有两个变体，前缀版本++x和后缀版本x++,两个版本队操作数的影响是相同的，但是影响时间不同 123int x = 5;int y = x++; //y=5,x=6int z = ++x; //z=6,x=6 这种影响时间的不同，可能会让规则有些模糊，这里引入一个概念，两个-副作用和顺序点副作用是指在计算表达式时对某些东西（如存储在变量中的值）进行了修改顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用进行了评估。C++中，语句的分号就是一个顺序点，这意味这程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改必须完成，顺序点在C++11中被舍弃，取而代之使用“顺序”的术语。 任何完整表达式的末尾都是一个顺序点， 12while(guests++&lt;10)cout&lt;&lt;guests&lt;&lt;endl; //guests的自增1在上一步完成，这步输出自增1后的guests 这里while循环中条件表达式和cout的输出表达式都是一个完整的表达式。 对于用户定义的类型，如果有用户定义的递增递减运算符，则前缀格式的效率更高。 当++和–遇到指针，前缀++、前缀–和解除引用运算符的优先级相同，以从右到左的方式进行结合，例如*++ptr,ptr自增1,在应用解除引用后缀++、后缀–优先级相同，但比前缀优先级高，这两个运算符以从左到右的方式结合 1234567double arr[5] = &#123;1,2,3,4,5&#125;;double *ptr=arr;++ptr; //ptr指向arr[1]double x = *++ptr; //ptr自增1,再应用*，x=3++*ptr; //ptr仍指向arr[2]，但arr[2]=4(*ptr)++; //ptr仍指向arr[2]，但arr[2]=5x = *ptr++; //后缀优先级高，所以ptr先自增1,在应用*,*是应用在递增前的地址，所以x=arr[5]=5,语句执行完之后，ptr的值会变成arr[3]的地址 逗号运算符逗号运算符最常见的用途是将两个或更多的表达式放到一个for循环表达式中，不过C++还为它提供了另外两个特性。首先，它确保先计算第一个表达式，然后计算第二个表达式（即逗号运算符是一个顺序点），i = 20, j= i * 2; // j= 40;其次，C++规定，逗号表达式的值是第二部分的值，例如，上边表达式的值为40。 12cat = 16,24; //等同于(cat=16),24;cat =(16,24); //cat = 24; 在所有运算符中，逗号运算符的优先级是最低的，所以，上边表达式1中cat=16又由于逗号表达式的值是第二部分的值，而括号的优先级最高，所以表达式2中 cat=24 关系表达式&lt; &lt;= == &gt; &gt;= !=关系运算符的优先级比算术运算符的优先级低x + 3 &gt; y - 2;等同于 (x + 3)&gt;(y - 2); C-风格字符串和string类字符串的比较C++将C-风格字符串视为地址，因此如果使用关系运算符来比较他们，比较的是地址而非字符串本身，C-风格字符串库中提供了这样一个比较函数strcmp()，接受两个字符串地址作为参数，参数可以是指针、字符串常量或字符数组名。 关系运算符虽然不能比较字符串，但可以用来比较字符，因为字符实际上是整型。、 string类字符串可以使用关系运算符进行比较，参与比较的两个操作数，至少有一个是string对象，另一个是C-风格字符串也可以。 while循环tip:要打印字符的ASCII码，必须通过强制类型转换将name[i](name是一个C-风格字符串）转换为整型，这样cout将把值打印成整数，而不是将它解释为字符编码。 编写延时循环头文件ctime提供了这样一个解决方案，首先，它定义了一个符号常量-CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数。ctime将clock_t作为clock()返回类型的别名，就是说可以将变量声明为clock_t类型，扁你其根据系统来将它转换为long、unsigned int等 123456789#include&lt;ctime&gt;...float secs;cin&gt;&gt;secs;clock_t delay = secs * CLOCKS_PER_SEC;clock_t start = clock();while(clock() - start &lt; delay);cout&lt;&lt;&quot;delay end&quot;;return 0; 类型别名 类型别名就是类型的别名，C++有两种创建类型别名的方式 #define BYTE char预处理器将在编译程序时用char替换掉程序中所有的BYTE，从而BYTE就成了char的类型别名 typedef char byte，byte成了char的类型别名typedef char* bytePointer,bytePointer是char指针的别名 在使用类型别名声明一系列变量是，typedef更合适 1234#define BYTE char*;BYTE P1,P2; //p1是char指针，p2只是char类型变量typedef char byte;byte p1,p2; //p1,p2都是char类型的变量 typedef不会创建新类型，这也是为什么叫类型别名的原因，即只是为已有类型取个新名字。 do while循环不写 基于范围的for循环（C++11)基于范围的for循环是C++11的新增内容，简化了常见的循环任务，例如对数组，vector等中的每个元素做相同的操作。 12345double natus[5]=&#123;1,2,3,4,5&#125;;for(double x : natus) cout&lt;&lt;x&lt;&lt;std::endl;for(double &amp;x: natus) x*=100; 循环和文本输入cin 1234567891011121314char ch;int count=0;cout&lt;&lt;&quot;enter # to quit&quot;;cin&gt;&gt;ch;while(ch != &apos;#&apos;)&#123; cout&lt;&lt;ch; ++count; cin&gt;&gt;ch;&#125;cout&lt;&lt;count&lt;&lt;std::endl;return 0;输入：see ken run#really输出：seekenrun 9 程序输出的时候省略了空格，不仅没有读取到ch中，也没有计数。这是因为cin在读取char值的时候，与读取其他类型一样，会直接忽略换行符和空格。还有一点就是在我们从键盘输入的时候，发送给cin的输入被缓冲，，之只有在按下enter后，才会将输入发送给程序 cin.get()在上边程序中使用cin.get(ch)，它会读取输入中的下一个字符，无论是否是空格。cin.get()有几个变体， 12345char name[Arsize&#125;;...cin.get(name,ArSize); //连续读取Arsize个字符到name字符数组中cin.get(); //读取下一个字符，即使是空格和换行，它常用来读取末尾的换行符cin.get(ch); //读取下一个字符，忽略空格和换行符 文件尾条件没看懂，写不出来 循环嵌套和二维数组没啥好写的]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>循环和关系表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day7]]></title>
    <url>%2F2019%2F09%2F16%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day7%2F</url>
    <content type="text"><![CDATA[写完第四章最后一点内容，over 复合类型指针指针用于存储值的地址，指针名就是地址，使用*运算符即解除引用运算符用于指针，可得到该地址处存储的值。一般变量使用&amp;地址运算符得到变量地址。 1234int* ptr; //指向int的指针int* p1,p2; //一个指针，一个int变量int btr=2;int* pt= &amp;btr; //将pt初始化为btr的地址 一定要在对指针应用解除引用运算符(*)之前，将指针初始化为一个确定的适当的地址 1234int* pt;*pt=1000; //在pt指向的地址存一个int值1000pt=0xB8000000; //类型不匹配，不能将整数直接赋给指针pt=(int*) 0xB8000000; //强制转换类型，类型匹配 使用new分配内存在C语言中，常常用库函数malloc()分配内存，在C++中则使用new,这也是指针真正的用武之地-在运行阶段分配未命名的内存来存储值。int* pt=new int;地址本身只指出了对象存储地址的开始，而没有指出其类型（使用的字节数） delete释放内存 12int* ptr= new int;delete ptr; 1、释放ptr指向的内存，但不会删除ptr指针。2、配对使用new和delete，否则会发生内存泄漏3、不能重复释放已经释放的内存块，这样的结果是不确定的，对空指针使用delete是安全的 new创建动态数组 12int* ptr= new int [10];//new运算符返回第一个元素的地址delete [] ptr; //free动态数组 1、不能使用delete释放非new分配的内存2、不能使用delete释放同一个内存两次3、只能使用delete[]释放new[]为数组分配的内存4、new[]为数组分配内存，程序是跟踪了分配的内存量(元素数目)的，这样delete[]才能正确释放内存，但是这种信息非公用，不能用sizeof来确定new[]的字节数 C++将数组名解释为地址 123double wage[2]=&#123;2.3&#125;;double* p1=wage;double* p2=&amp;wage[0];//这两个指针指向同一块内存 很多情况下，可以以相同的方式使用指针名和数组名。区别是，1、可以修改指针的值，但是不能修改数组名的值，数组名是常量 2、对数组使用sizeof得到的数组的长度，C++不会将数组名解释为地址，对指针应用得到指针的长度 123456int stack[10]=&#123;1,2,3&#125;;//stack= &amp;stack[0];//*(stack+1)=stack[1];int* ptr=stack;ptr=ptr+1; //validstack=stack+1// not allowed 对数组名使用地址运算符时，得到的是整个数组的地址&amp;stack[0]（即stack）是一个4个字节内存块的地址，&amp;stack是一个40字节内存块的地址 指针和字符串 123char flower[10]=&quot;rose&quot;;cout&lt;&lt;flower&lt;&lt;&quot;s are red\n&quot;;cout&lt;&lt;(int*)flower&lt;&lt;endl; 给cout提供指针，它会打印地址，但是如果指针类型为char*,cout将打印字符串（数组名是第一个元素的地址，cout对象认为char的地址是字符串的地址，因此打印该地址的字符时，将继续打印后边的字符，直到遇到空字符’\n’为止，”s are red\n”字符串在这里也被解释为第一个字符的地址，在cout和多数C++表达式中，char数组名，char指针以及用引号括起来的字符串常量都被解释为字符串第一个字符的地址。），如果要显示字符串的地址，需要将指针强制转换为另一种指针类型，如int *leixing . 应使用strcpy()或strncpy()，而不是赋值运算符将字符串赋给数组。因为strcpy(参数1，参数2)，如果字符串的长度比数组大，则复制可能会导致覆盖数组后边的内存，strncpy()函数可以避免这种问题， 12strncpy(food,&quot;a picnic basket filled with tomatos&quot;,12);food[12]=&apos;\n&apos;; new创建动态数组 123456struct things&#123; int good; int bad;&#125;;things* ps=new things; //把足以存储things结构的一块内存地址赋给ps 动态结构创建后，因为没有名称，只知道地址，所以在访问成员时，不能使用成员运算符(.)，取而代之使用箭头成员运算符-&gt;,things-&gt;good. 自动存储、静态存储和动态存储1、自动存储在函数内部定义的常规变量使用自动存储空间，即自动变量。自动变量是局部变量，作用域为包含它的代码块，自动变量通常存储在栈中2、静态存储静态存储是整个程序执行期间一直存在的存储方式，一种方式在函数外部定义变量，另一种用static关键字声明3、动态存储new和delete，使得变量能够在一个函数中分配内存，在另一个函数中释放它。 模板类vector和arrayvector也是一种动态数组，new创建动态数组的替代品。 1234567#include&lt;vector&gt;using namespace std; //vector包含书头文件vector和std名称空间中vector&lt;int&gt;v; //v是一个vector&lt;int&gt;对象int n;cin&gt;&gt;n;vector&lt;double&gt;vd(n); //能够存储n个double元素的vector&lt;double&gt;对象。vector&lt;typeName&gt;vt(n_elem); //n_elem整型常量或者变量都可以 array和数组一样，长度也是固定的，也是用栈（静态内存分配） 123456#include&lt;array&gt;using namespace std;array&lt;int,5&gt;ar; //包含5个int元素的array对象array&lt;double,4&gt;ad=&#123;1.2,1.2,1.2,1.2&#125;;array&lt;double,4&gt;ai;ai=ad; //valid array的长度固定，所以创建时的元素数目必须是常量。对于array对象来说，可以直接将一个array对象赋给另一个array对象，但对于数组来说，必须逐元素复制。 123vector&lt;int&gt;vt(4);vt[-2]=20; //validvt.at(1) = 2; //valid，将2赋给vt[1] vt[-2]等于*(vt-2),即会把20存储到数组外边，使用成员函数at(),能够在运行期间捕获非法索引]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>复合数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day6]]></title>
    <url>%2F2019%2F08%2F20%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day6%2F</url>
    <content type="text"><![CDATA[接着昨天的写，第九章最后一点内容了，写完煮个饺子吧，over 名称空间创建名称空间 123456namespace Jack&#123; double pail; void fetch(); int pal; struct Well&#123;...&#125;;&#125; 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中，因此，默认情况下，名称空间中声明的名称链接性是外部的。 名称空间是开放的，可以把名称加入到已有的名称空间中。 访问名称空间中的名称，是用过作用域解析运算符::，使用名称空间来限定该名称。Jack::pail=1;作用域解析运算符在之前还有过一次应用，是在局部变量隐藏同名全局变量的时候，例如::number来访问number的全局变量版本 using声明和using编译指令using声明使特定的标识符可用，如using std::cout;using编译指令使整个名称空间可用，using namespace std; using声明若在main()函数外，则将名称添加到全局变量，在main()函数内，则是局部变量，由于变量的单定义规则，要注意同名变量的声明。 using声明和using编译指令都增加了名称冲突的可能性。 using编译指令导入所有的名称，但包括可能不需要的名称，如果与局部名称发生冲突，局部名称将覆盖名称空间版本，而编译器不会发出警告。 名称空间还可以嵌套 123456789namespace elements&#123; namespace fire &#123; int flame; ... &#125; float water;&#125; using namespace elements;=using namespace elements;+using namespace fire; 给名称空间创建别名，namespace ele=elements;,利用这种技术，简化嵌套名称空间的使用namespace fla=elements::fire::flame; 未命名的名称空间，该名称空间中的名称，就像链接性为内部的静态变量。 名称空间不在头文件中使用using编译指令，首先，这样做掩盖了要让那些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用using编译指令，在放在所有预处理编译指令#include之后。 导入名称时，首选使用作用域解析运算符或using声明的方法。 对于using声明，首先将其作用域设置为局部而不是全局]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>内存模型和名称空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day5]]></title>
    <url>%2F2019%2F08%2F19%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day5%2F</url>
    <content type="text"><![CDATA[今天day3没写完的那章，不知道今天能不能写完，over 内存模型和名称空间接### 存储持续性、作用域和链接性 说明符和限定符说明符和限定符提供有关存储的信息。存储说明符：auto(C++11中不再是说明符)；register;static;extern;thread_local(C++11新增)；mutable. 在同一个声明中不能使用多个说明符，除了thread_local，它可以和static或extern结合使用。auto在C++11中用于自动类型推断。（C++之前是声明自动变量）register在C++11中只是显式地指出变量是自动的。static和extern不想写了thread_local指出变量的持续性和其所属线程的持续性相同。mutable指出，结构或类的变量为const，其某个成员（被mutable声明的）也可以被修改 12345678struct data&#123; char name[20]; mutable int accesses;&#125;;const data major=&#123;&quot;Claybourne Clodde&quot;, 0&#125;;strcpy(major.name,&quot;Joye Joux&quot;);major.accesses++; cv-限定符const,volatile. 关键字volatile表明，及时程序代码没有对内存单元进行修改，其值也可能发生变化。 默认情况下，全局变量的链接性是外部的，但const全局变量的链接性是内部的，就像static全局变量一样const int lemon=3;int main(){...},内部链接性意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量，这样只要两个源代码文件包括同一个头文件，它们将获得同一组变量。 可以使用extern关键字来覆盖默认的内部链接性，extern const int fingers=10;,这种情况下所有使用该变量的文件中都应使用extern关键字声明它。（常规外部变量是定义时直接定义，但在其他文件中使用时必须要用extern。 函数和链接性 C++不允许在一个函数中定义另一个函数，因此所有的函数的存储持续性都自动为静态的，即在程序执行期间，函数一直存在。 函数的链接性默认是外部的，在其他文件中使用时要要extern关键字 static关键字将函数的链接性设置为内部的，就像static全局变量一样，只能在一个文件使用，且static函数的原型和定义都必须使用static。 C++查找函数：程序调用函数时，如果文件中的函数原型指出函数是静态的，则编译器将旨在该文件中查找该函数定义；否则，编译器将在所有程序文件中查找。如果找到两个定义，则发出错误消息；如果没找到，则编译器将在库中搜索。 语言链接性 因为链接程序要求每个不同的函数都有不同的符号名，但是C++中，同一个名称可能对应多个函数（多态），所以C++编译器会执行名称矫正或名称修饰 ，为重载函数生成不同的符号名称。这种方法就称为-C++语言链接。 例如spiff(int)转换为spiff_i,而将spiff(double,double)转换为spiff_d_d. 在使用C库中预编译的函数是，应在函数原型中指出要使用的约定extern void spoff(int);或者extern &quot;C++&quot; void spaff(int); 存储方案和动态分配C++运算符new分配的内存，就叫做动态内存，动态内存由new和delete控制，而不是由作用域和链接性规则控制，因此可以在一个函数中new内存，另一个函数中delete内存。编译器通常使用三块独立的内存：一块用于静态变量，一块用于自动变量，另一块用于动态存储。 new初始化： 123456789new * pi=new int &#123;6&#125;; // *pi set to 6struct coordinate&#123; double x; double y; double z;&#125;;coordinates * qing= new where &#123;2.3，2.3，2.3&#125;；int * ptr= new int [4] &#123;1,2,3,4&#125;; int * pi=new int;将被转换为int * pi=new(sizeof(int)); 定位new运算符 定位new运算符是让程序员指定要使用的位置，通常的new是在堆（heap)中找到一个足以能够满足要求的内存块。使用定位new时，要包含头文件new,include&lt;new&gt;;,除了需要指定参数，其他和new无异。 123char buffer[20];double * pi;pi= new (buffer) double[5]; 名称空间在C++中，名称可以是变量、函数、结构、枚举、类的成员等，当项目增大，是个多个厂商的类库时，就可能导致名称冲突-两个库都定义了List类，但用户希望使用这个库的List类，使用那个库的Tree库，名称空间即可解决这种问题。 果然没写完，打会CSGO，看会书睡觉，明天再写为了分类方便，还是接着昨天写吧123456namespace Jack&#123; double pail; void fetch(); int pal; struct Well&#123;...&#125;;&#125; 蒙城空间可以是全局的，也可以位于另一个名称空间中]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>内存模型和名称空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day4]]></title>
    <url>%2F2019%2F08%2F18%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day4%2F</url>
    <content type="text"><![CDATA[接上次复习，复合类型，写完了string类，over 复合类型结构简介结构是为了同时存储多种类型的数据,使用struct关键字。 123456struct inflatable&#123; char name[20]; float volume; double price;&#125;; 创建inflatable类型的变量，inflatable hat;,使用成员运算符(.)来访问各个成员，hat.price. 结构的声明通常在main()函数的前边-外部声明，外部声明可以被后面任何函数使用，但不提倡使用外部变量。 初始化 123456inflatable hat=&#123; &quot;Glorious&quot;, 1.88, 29.99&#125;; 使用(,)分隔值列表。 C++使用户定义的类型与内置类型尽可能相似，可以将结构作为参数传递给函数，也可以让函数放回一个结构，可以用=将结构赋给另一个同类型结构。 可以在定义结构时同时常见结构变量。 12345struct perks&#123; char name[20]; int key;&#125;smith,edward; //创建两个perks变量 结构数组元素为结构的数组。perks smith[20]; 结构数组的初始化和数组相同， 12345perks g2[20]=&#123; &#123;&quot;smith&quot;,5&#125;, &#123;&quot;edward&quot;,6&#125;&#125;; 结构中的位字段 123456struct torgle_register&#123; unsigned int SN : 6; //6 bits for SN value; unsigned int : 4; //4 bits unused; bool goodIn : 1;&#125; 共用体union共用体是一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。 共用体常用于节省内存，还有操作系统数据结构或硬件数据结构。 例如union perks,perks.name=”shox”; //存储一个char常量perks.key=4; //存储int常量，但同时char常量丢失 由于共用体每个时刻只能存储一个值，因此共用体的长度为其最大成员的长度。 共用体的用途之一，例如管理一个小商品目录，有的商品ID是整数，有的ID是字符串。 12345678910111213struct widget&#123; char brand[20]; int type; union id &#123; long id_num; char id_char[20]; &#125;id_val;&#125;:...widger price;cout&lt;&lt;price.id_val.id_num; 还有一种匿名共用体-没有名称，成员是位于相同地址处的变量。匿名共用体，union {…};省略(id)这个名称，在后边使用时，cout&lt;&lt;price.id_num; 枚举enum工具提供了另一种创建符号常量的方式，这种方式可以替代const。enum spectrum {red,orange,yellow,green,blue};spectrum成为新类型的名称，枚举类型red,orange作为符号常量，对应0~5，枚举量 spectrum变量受到限制，只有在列表中的值是可能的 123456789spectrum band;band = red; //validband = black; //invalid++band; //invalid,C++没有为枚举定义算术运算band =red + orange; //invalid,bang=0+1,int不能转换成枚举int color= blue; //valid,枚举类型可以转换成int类型band=4; //invalid,int型不能转换称枚举类型color =3 + red;// validband=spectrum(2);//valid,int值有效的情况下，可强制转换 设置枚举量的值 123enum bits&#123;one=1,two=2,fout=4,five&#125;; //指定的值必须是整数enum bitss&#123;shox,kennys=200,apex&#125;; //shox=0,apex=201enum bitsss&#123;zero,null=0,one,onee=1&#125;; //zero=0,one=1,可以创创建多个值相同的枚举量 枚举的取值范围 每个枚举都有取值范围，通过强制类型转换，可以将取值范围的任何整数值赋给枚举变量，即使这个值不是枚举值，例如前边的band=spectrun(2); 取值范围的定义：上限，知道枚举量的最大值，找到大于这个最大值的、最小的2的幂，将它减去1，即是取值范围上限下线，如果枚举量最小值&gt;=0，则下限为0，否则得下限的规则同上限]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>复合数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day3]]></title>
    <url>%2F2019%2F08%2F14%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day3%2F</url>
    <content type="text"><![CDATA[今天看第九章-内存模型和名称空间，明天再继续写之前的，over 内存模型和名称空间单独编译通常，大型程序都是由多个源代码文件组成，这些文件可能共享一些数据，这就涉及到程序文件的单独编译。 头文件：包含结构声明和使用这些结构的函数的原型源代码文件：包含与结构有关的函数的代码源代码文件：包含调用与结构相关的代码 不能将函数定义和变量声明放在头文件中，因为如果在头文件中包含一个函数定义，然后在另外两个文件中包含该头文件，则同意程序中将包含同一函数的两个定义，除非函数是内联的，否则就会出错。 头文件：函数原型。 使用#define或const定义的符号常量。 结构声明。 类声明。 模板声明。 内联函数。 在包含自己的头文件时，应使用引号而不是尖括号。如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在引号中，则编译器将首先查找当前工作目录或者源代码目录，如果没找到，则在标准位置查找。 12#ifndef COORDIN_H#define COORDIN_H 同一个文件中只能将同一个头文件包含一次。基于预处理器编译指令#ifndef，可以避免在不知情的情况下，使用包含了另一个头文件的头文件导致错误，这种方法并不能防止编译器将文件包含两次，而是让他忽略除第一次包含之外的所有内容。 #define也能用来创建符号常量，#define MIXMUM 99 存储持续性、作用域和链接性自动存储持续性：在函数定义中声明的变量的存储持续性为自动的，函数或代码块执行完，使用的内存自动释放。静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量，在程序整个运行过程都存在。线程存储持续性：多核处理器的cpu同时处理多个执行任务，这让程序能够将计算放在可并行处理的不同线程中。动态存储持续性：是用new运算符分配的内存将一直存在，知道使用delete运算符将器释放或程序结束。 作用域描述了名称在文件的多大范围可见。链接性描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，自动变量的名称没有链接性，不能共享。 C++函数的作用域可以是整个类或整个名称空间，但不能是局部的，因为不能在代码块内定义函数，如果函数的作用域为局部，则只对它自己可见，因此不能被其他函数调用。 自动存储持续性在函数中生命的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。 如果在内部代码块中定义了一个外部代码块中已经定义的同名变量，则程序在执行内粗代码块中的语句时，新的定义隐藏hide以前的定义，新定义可见，旧定义暂时不可见，此代码块执行完，原来的定义重新可见。 C++管理自动变量的方法是留出一段内存-栈。 寄存器变量，使用关键字register，register int guardian_num;,它建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度。在C++11中，已经失去了这种作用。 静态持续变量C++为静态存储持续性变量提供了3种链接性，外部链接性（可在其他文件中访问），内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中使用）。 静态变量的数目在程序运行空间不变，所以没有特殊装置管理。 12345678910int global=1; //static duration,external linkagestatic int one_file=2; //静态持续，内部链接性int main()&#123; ...&#125;void funct1（int n)&#123; static int count=0; //静态持续变量，无链接性&#125; 所有的静态持续变量，未被初始化的静态变量的所有位都被设置位0，这种变量成为零初始化的zero-initialized。 零初始化和常量表达式初始化都成为静态初始化，编译器处理文件时初始化变量。动态初始化意味着变量在编译后初始化。 所有静态变量都被零初始化，不论是否显式的初始化了它；如果常量表达式初始化了变量，且编译器根据文件内容就能及计算表达式，编译器将执行常量表达式初始化。如果没有足够的信息，变量将备东陶初始化。 12345#include&lt;cmath&gt;int x; //零初始化int y=5; //常量表达式初始化long z=13*78; //常量表达式初始化const double pi=4.0*atan(1.0); //动态初始化 x,y,z,pi都被零初始化，之后y和z在被常量表达式初始化，pi初始化由于要调用atan()，所以需要等到该函数被链接且程序执行时。 静态持续性、外部链接性链接性为外部的变量通常成为外部变量，存储持续性为静态，作用域为整个文件。也称全局变量。 单定义规则-变量只能有一次定义，C++提供两种变量声明，一种是定义声明或称定义，给变量分配存储空间；另一种是引用声明或称声明，不给变量分配存储空间，因为它引用已有的变量。 引用声明使用关键字extern，不进行初始化，否则声明为定义，导致分配存储空间。 123int kennys;extern int shox; //shox defing elsewhereextern char gr= &apos;z&apos;; //definition because initialized 如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字extern声明它。 external.cpp 123456789//compile with support.cpp#include&lt;iostream&gt;using namespace std;double warming = 1.2;void update(double dt);int main()&#123; update(2);&#125; support.cpp 12345678910111213//compile with external.cpp#include&lt;iostream&gt;extern double warming; //声明warming，在该文件中使用void update(double dt);using std::cout;void update(double dt)&#123; double warming=0.4; //局部变量hide全局变量 cout&lt;&lt;&quot;new warming&quot;&lt;&lt;warming&lt;&lt;endl; cout&lt;&lt;&quot;global variable&quot;&lt;&lt;::warming; //使用::作用域解析运算符&#125; 作用域解析运算符::放在变量名前边，表示使用该变量的群居版本。 静态持续性、内部链接性static限定符用于作用域为整个文件的变量时，该变量的链接性为内部。 如果文件定义了一个静态外部变量 1234567//file1int errors=0;...//file2static int error=20;void froobish()&#123;cout&lt;&lt;error&lt;&lt;endl;&#125; 其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。 静态存储持续性、无链接性即局部变量 如果初始化了静态局部变量,则程序只在启动时进行一次初始化，以后再调用函数时，将不会像自动变量那样再次初始化。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>内存模型和名称空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的ub4.0被偷了]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%88%91%E7%9A%84ub4-0%E8%A2%AB%E5%81%B7%E4%BA%86%2F</url>
    <content type="text"><![CDATA[今天是个值得纪念的日子，于2019年8月13日北京时间10点到12点，我的ub被偷了 for(int i=0; ;i++){ cout&lt;&lt;”CNMD，为什么要偷鞋？”;}]]></content>
      <categories>
        <category>不是日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day2]]></title>
    <url>%2F2019%2F08%2F12%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day2%2F</url>
    <content type="text"><![CDATA[上周追了一周剧，是时候继续学习了，今天是第四章-复合类型，over 复合类型数组array数组是一种数据格式，存储多个同类型的值，在内存中依次存储数组的各个元素。 数组的有效下标值十分重要，因为编译器不会检查使用的下表是否有效。 数组的初始化规则：只有在定义数组时才能进行初始化，此后就不行，也不能将一个数组赋值给另一个数组；可以只初始化数组的一部分元素；初始化可以不写【下标值】。C++11的新方法，初始化是可省略等号；大括号内的初始化列标可为空；初始化禁止缩窄转换，例如浮点数转换为整型是缩窄转换。 字符串字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种，C-风格字符串和基于string类库。C-风格字符串，以空字符(\0)结尾，char C[100]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;}; //a string如果最后没有空字符，那么这个数组就不是字符串，有很多函数在处理字符串时，就是遇到空字符为止。 另一种将字符数组初始化为字符串的方法，即字符常量。char simple=&quot;simple&quot;; 空字符在这里被隐藏了。 字符常量和字符串常量我经常搞混字符常量’S’,使用单引号,’S’是83的另一种写法，可用来赋值，char size=’S’,83赋给size字符串常量”S”，使用双引号，表示的是两个字符（S和\0）组成的字符串，”S”是字符串的地址。 任何两个由空白(空格，制表符和换行符)分割的字符串常量都将自动拼接成一个。这两个输出等效 12cout&lt;&lt;&quot;this is dex404&quot; &quot;bloging in my little room.\n&quot;;cout&lt;&lt;&quot;this is dex404 bloging in my little room.\n&quot;; 拼接时不会在被连接的字符串之间添加空格，第一个字符串后面的\0将被第二个字符串的第一个字符取代 将字符串存储到数组中，常用两种方法 12345char life[32]=&quot;life is fantastic,without work&quot;;char life2[32];cout&gt;&gt;&quot;how&apos;s life?&quot;;cin&gt;&gt;life2;cout&lt;&lt;strlen(life)&lt;&lt;sizeof(life2)&lt;&lt;&quot;\n&quot;; strlen(life)计算life数组的字符串长度，即字符数量，不计算空字符。sizeof(life)返回整个数组的长度，而不是数组内元素数量，元素数量=sizeof(life)/sizeof(char); 面向行的输入：istream中的类（如cin)提供的面向行的类成员函数getline()和get()，取一行输入，直到达到换行符。区别是getline()丢弃换行符，get()将换行符保留在输入序列中。 cin.getline(book,10);,这行包含的字符不超过19个。 get()函数有几种变体， 123cin.get(name,ArSize); //和getline()功能相似cin.get(); //读取下一个字符，常用来处理换行符，因为get()调用后，换行符会被保留在输入行中，因此若直接调用第二个get(name2,ArSize),第一个字符就是换行符，直接结束。cin.get(name,ArSize).get(); //将上边两个类成员函数合并，实现上边两条语句的功能。 get()函数的这种特性，叫做函数重载 失效位，当get()读取空行后，将设置失效位（failbit),这将是接下来的输入被阻断，使用cin.clear()函数来回复输入。在输入字符串比分配的空间大时，getline和get都会将余下的字符留到输入队列中，getline()设置失效为。 string类include&lt;string&gt; 可以使用string类型的变量而不是字符数组来存储字符串，很多方面，使用string对象的方式与字符数组相同。1、可以使用c-风格字符串来初始化string对象，即string jame=&quot;jame6&quot;;2、cin&gt;&gt;jame;3、cout&lt;&lt;jame;4、jame[2]; string对象和字符数组之间的区别主要是string对象可以声明为简单变量string jame;,不初始化，但是字符数组的初始化只能在声明时完成，之后就不能在初始化。 123456string jame=&quot;jame6&quot;;string shox;shox=jame; //shox=&quot;jame6&quot;;string cold;cold=jame+shox; //cold=&quot;jame6jame6&quot;jame+=cold; //jame=&quot;jame6✖3&quot; 转义序列&quot;表示双引号cout&lt;&lt;&quot;j6me= \&quot;king of old 6\&quot;\n&quot;; string类使得对字符串的操作更简单，在新增string类之前，使用函数来完成诸如赋值一类的操作#include&lt;cstring&gt; 1234567char allu1[20];char allu2[20]=&quot;botallu&quot;;string kennyS=&quot;king of awper&quot;;strcpy(allu1,allu2); //将字符串复制到字符数组中strcat(allu1,allu2); //将字符串附加到字符数组的末尾int ratingofallu=strlen(allu1); //strlen()获取allu1字符串的长度，接受一个C-风格字符串做参数int ratingofkennyS=kennyS.size(); //.size()获取string对象的长度,size()是string的方法 像前边提过的，字符数组的有效下标值十分重要，因为数组太小，会产生无法存储指定信息的危险，但是string类具有自动调整大小的功能，避免这种问题。 string类的I/O，string对象也可以使用cin&gt;&gt;和cout&lt;&lt;,但是在读取一行而不是一个单词的时候，string对象的处理方法不同， 12cin.getline(zeus,50); //C-风格字符串getline(cin,str); //str是string对象 to be continued class Solution {public: string longestPalindrome(string s) { int stringLeft=0,stringRight=0; int Max=0; int sLen=s.size(); if(sLen==0 || sLen==1) return s; for(int i=0;i&lt;sLen;i++) { int Len1=expandaroundcenter(s,i,i); int Len2=expandaroundcenter(s,i,i+1); Max=max(max(Len1,Len2),Max); if(Max&gt;stringRight-stringLeft+1) stringLeft=i-(Max-1)/2; } return s.substr(stringLeft,Max); }private: int expandaroundcenter(string str,int left,int right) { int L=left,R=right; while(L&gt;=0 &amp;&amp; R&lt;str.size() &amp;&amp; str[L]==str[R]) { L–;R++; } return R-L-1; }};]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>复合数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记day1]]></title>
    <url>%2F2019%2F08%2F06%2FC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day1%2F</url>
    <content type="text"><![CDATA[今天是写博客的第一天，记录一下C++学习过程，用的教材是C++ Primer Plus,今天是从本书第3章-处理数据开始记录，这里很多知识都不会写下来，只记些我常忘的或者重要的，over 处理数据1、变量名命名 C++提倡使用有含义的变量名，例如cost_of_trip,这种命名做法通常是用下划线字符将单词隔开，或者从第二个单词开始每个单词的首字母大写，如costOfTrip，命名风格在第二张有讨论，我觉得这个取决个人习惯吧。 C++变量名命名规则如下： 1&gt;名称中只能使用字母字符、数字和下划线—— 2&gt;名称的第一个字符不能是数字 3&gt;区分大小写 4&gt;不能将C++关键字用作名称 5&gt;以两个下划线或下划线和大写字母开头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符 6&gt;C++对于名称的长度没有限制，但是有些平台有长度限制 2、整型 short、int、long、long long,C++规定了最小长度，short至少16位（bit),int至少与short一样长，long至少32位，且至少与int一样长，long long至少64位，且至少与long一样长。 计算机内存的基本单元是位(bit),8位单元可以表示0-255或者-128-127，每增加一位，组合数便加倍，字节通常指的是8位的内存单元，即1 byte=8 bit; sizeof()运算符指出，在使用8位字节系统中，int的长度位4个字节，short是2个字节。 整型的无符号类型，优点是增大变量能够存储的最大值，在整型超越限制值最大最小值时，整型的表现就像钟表，其值将为范围另一端的值。 3、char char最常被用来处理字符，但也可以将用作比short更小的整型。 字符常量的书写方式，最常用的是将字符用单引号括起来，’A’,这种表示法代表的是字符的数值编码，在ASCII系统中，’A’为65，即字符A的ASC码。 C++将一些字符赋予了含义–转义序列， 123cout&lt;&lt;endl; //using the endl manipulator;cout&lt;&lt;&apos;\n&apos;; //using a character constant;cout&lt;&lt;&quot;\n&quot;; //using a string; 都能实现将光标移到下一行。 const限定符 使用const来定义符号常量，如const int Wifes=3000; 便可以在程序中使用Wifes，在定义符号常量时，通常会将首字母大写，有助于区分变量和常量。 如果在声明变量时没有赋值，则该常量值不确定，且在程序中不能修改。 浮点数 计算机将带有小数部分的数字分成两部分存储，一部分表示值，另一部分用于对值进行放大或缩小，例如123.4567和12.34567，可以表示成0.1234567(基准值)和1000（缩放因子），0.1234567和100，缩放因子的作用就是移动小数点的位置，术语浮点因此得名，C++是基于二进制数。 float至少32位，double至少48位，且不少于float,long double至少和double一样多。 在用cout输出浮点数时，cout通常会删除结尾的零，所以可以调用cout.setf(ios_base::fixed, ios_base::floatfield); ios_bash::fixed是设置cout为定点输出格式，ios_bash::floatdield是设置输出时按浮点格式，小数点后有6位数字。因为float只能保证6位有效位。 ###算术运算符 除法运算符（/）的行为取决于操作数的类型。如果两个操作数都是证书，则C++执行整数除法，即小数点被丢弃，结果为整数。如果其中有一个操作数是浮点值，则小数部分被保留，结果为浮点数。 强制类型转换 12int bots=20long (bots) 强制类型转换不会修改变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值 static_cast&lt;long&gt; (bots) 也是一种强制类型转换运算符，还有集中将在15章介绍。 auto 使用关键字auto，让编译器能够根据初始值的类型推断变量的类型。 auto n=100; n is int 在处理复杂类型，如标准模板库STL中的类型时，auto的优势才能显现出来。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
